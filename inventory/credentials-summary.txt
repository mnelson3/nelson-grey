Workspace credential & runner inventory
=====================================

Overview
--------
- Central store: this repo (`nelson-grey`) is designated as the canonical location for shared provisioning/cert artifacts and runner automation helpers.

Per-repository findings (high priority)
--------------------------------------

1) modulo-squares
  - `packages/mobile/ios/asc_private_key.p8` (App Store Connect API key name referenced in .gitignore and workflows)
  - `packages/mobile/ios/*.p8` (any other .p8 files)
  - `packages/mobile/ios/certs/*.p12`, `*.pem` (iOS distribution certificates)
  - `packages/mobile/ios/*.mobileprovision` (provisioning profiles)
  - helpers: `test-ios-secrets.sh` (imports/probes cert + profile), `ZERO-TOUCH-README.md`, `.github/workflows/ios-cicd-release.yml` (uses `secrets.ASC_PRIVATE_KEY`)

2) vehicle-vitals
  - root: `com.vehicle-vitals.runner-token-refresh.plist` (launch agent for token refresh)
  - `setup-github-app.sh` (expects GitHub App private key, writes `.github-app-private-key.pem`)
  - `actions-runner` helpers: `run.sh`, `run-helper.sh.template`, `svc.sh`, `runsvc.sh` and `automate.sh*` scripts referencing runner lifecycle
  - `_diag/` logs and installed runner artifacts contain `.credentials`, `.runner`, `.credentials_rsaparams`

3) wishlist-wizard
  - root: `firebase-service-account-dev.json`, `firebase-service-account-staging.json`, `firebase-service-account-prod.json`
  - root: `com.wishlist-wizard.runner-token-refresh.plist`
  - actions-runner helpers and run scripts similar to other repos

4) Actions-runner repositories (per-project)
  - `modulo-squares-actions-runner/`, `vehicle-vitals-actions-runner/`, `wishlist-wizard-actions-runner/`
  - contain runner startup scripts and templates: `run.sh`, `run-helper.sh.template`, `svc.sh`, `config.env.sh`, `bin/runsvc.sh`
  - `.gitignore` entries to prevent committing `actions-runner/`, certs and keys

5) nelson-grey (central)
  - README notes: "Contains all provisioning profiles for iOS/macOS applications." and managed by `fastlane match` (good starting point)
  - Recommended location to store: encrypted `fastlane match` repo, S3+KMS, or Vault-backed secrets/artefacts

Common credential filename patterns discovered
-------------------------------------------
- `*.p8` (App Store Connect private key)
- `*.p12`, `*.pfx` (exported iOS/macOS certs)
- `*.pem`, `*.cer` (certificate files)
- `*.mobileprovision` (provisioning profiles)
- `*.plist` (macOS launch agents for token refresh, e.g., `com.*.runner-token-refresh.plist`)
- `firebase-service-account-*.json` (Firebase service accounts)
- `.github-app-private-key.pem` (GitHub App private key)
- `.credentials`, `.credentials_rsaparams`, `.runner` (actions-runner installed state)

Short recommended next steps
----------------------------
1. Create `nelson-grey/secure/` (or configure Vault) to receive encrypted artifacts: `.p8`, `.p12`, `.mobileprovision`, `.pem`.
2. Run an expiry scan to extract expiry dates from artifacts and produce a rotation schedule.
   - Provisioning: `security cms -D -i <profile.mobileprovision>` (macOS) to inspect `ExpirationDate` and `TeamName`.
   - Certificates: `openssl pkcs12 -in <cert.p12> -nodes -nokeys -passin pass:<pw>` to inspect dates or `openssl x509 -in <cert.pem> -noout -enddate`.
3. Replace per-repo storage with references to `nelson-grey` secrets; update workflows to read secrets from central store (or CI secrets pointing to `nelson-grey` vault).
4. Prototype automation: Fastlane (`match` or `cert/provisioning_profile`) driven by App Store Connect API Key (.p8). Store `.p8` in central secrets store and provide ephemeral access to runners.
5. Implement a `runner-manager` service in `nelson-grey` to create GitHub registration tokens (via GitHub App) and push them to runner hosts for reliable re-registration.

Notes and risks
---------------
- Do not commit raw `.p12`, `.p8`, or service account JSON files into git. Use encrypted storage and access controls.
- Keep a rollback plan when rotating certificates and provisioning profiles; keep old keys available until new jobs succeed.

If you want, I can now run an automated expiry scan and produce a CSV of found artifacts + expiry dates (needs `security`/`openssl` on macOS). Proceed? 
